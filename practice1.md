# Практическое занятие 0, установка необходимого ПО и небольшой опрос.

# Установка необходимого ПО для работы с микроконтроллерами семейств STM32 и nRF52

## Что понадобится

Для программирования под микроконтроллеры с использованием операционной системы Riot нам понадобится компилятор, Unix-подобное окружение и система контроля версий Git. Также крайне желательно иметь какой-то "умный" текстовый редактор, или "легковесную IDE" - наверное, оптимальным вариантом на сегодня будет VSCode.

С Unix-подобным окружением «все сложно» - пользователи Linux и Mac OS X пользуются им сразу (заодно и Git там ставится легко и непринужденно), а в Windows есть два варианта: либо сравнительно медленная и не очень удобная среда MinGW (Minimal GNU for Windows) в версиях 8 и старше, либо WSL (Windows Subsystem for Linux) в Windows 10. В этом руководстве рассматривается только второй вариант - все-таки с момента выхода Windows 10 прошло уже больше 7 лет, и надеюсь, что ретроградов среди читателей нет.

### Установка Windows Subsystem for Linux (WSL) в Windows 10

Откройте магазин Microsoft Store, найдите в нём Ubuntu и установите. Если при первом запуске Ubuntu будет ругаться на выключенный компонент Windows, откройте системное приложение "Включение или отключение компонентов Windows", найдите там "Поддержка Windows для Linux" и включите. Дальнейшее будет во многом совпадать для "обычной" и вот такой встроенной в Windows Ubuntu.

## Компилятор

ARM распространяет свою версию gcc, которую можно скачать вот здесь:

https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads

(в том числе и для Linux – скорее всего, версия gcc-arm-none-eabi в дистрибутиве будет не той, что нам нужна, а последняя версия – это 12.2.Rel1). Пользователи Mac OS X могут установить компилятор обычным способом, скачав пакет с расширением pkg соответственно.

В Ubuntu и WSL скачайте компилятор и сопровождающие его утилиты (внимание: даже в WSL вам нужна 64-битная версия для Linux!), откройте Ubuntu, распакуйте архив (при этом проверьте путь к скачанному файлу, у вас он скорее всего будет отличаться; доступ к файловой системе Windows из WSL возможен через каталог `/mnt`) и укажите системе пути к нему (подсказка - для указания длинных названий файлов и каталогов в консоли можно набрать первые несколько букв и нажать Tab, при этом либо название дополнится до единственно возможного варианта, либо будут напечатаны имена файлов, начинающихся с этих букв - наберите название дальше и снова нажмите Tab):
```
cd /opt
sudo tar xJf /mnt/c/Users/YourName/Downloads/arm-gnu-toolchain-12.2.rel1-x86_64-arm-none-eabi.tar.xz
export PATH=/opt/arm-gnu-toolchain-12.2.rel1-x86_64-arm-none-eabi/bin/:$PATH
export PATH=/opt/arm-gnu-toolchain-12.2.rel1-x86_64-arm-none-eabi/arm-none-eabi/bin/:$PATH
```
В Mac OS X после установки достаточно только указать путь (необходимо проверить расположение после установки):
```
export PATH=/Applications/Arm/bin/:$PATH
```
или 

```
export PATH=/Applications/ArmGNUToolchain/12.2.rel1/arm-none-eabi/bin/:$PATH 
```

Проверить работоспособность компилятора можно командой
```
arm-none-eabi-gcc --version
```
Если все хорошо (выводится нужная версия компилятора) - добавьте путь к компилятору в файл `~/.bashrc` или `~/.bash_profile` (в зависимости от системы; в Ubuntu по умолчанию используется `.bashrc`). В последующих командах обратите внимание на косую черту перед знаком $ и перенаправление вывода в файл с помощью >> - если сделать его обычным способом, с помощью >, вы перезапишете свой старый `.bashrc` целиком и получите массу проблем. В Ubuntu это делается так:
```
echo "export PATH=/opt/arm-gnu-toolchain-12.2.rel1-x86_64-arm-none-eabi/bin/:\$PATH" >> ~/.bashrc
echo "export PATH=/opt/arm-gnu-toolchain-12.2.rel1-x86_64-arm-none-eabi/arm-none-eabi/bin/:\$PATH" >> ~/.bashrc
```
А в Mac OS X - так:
```
echo "export PATH=/Applications/Arm/bin/:\$PATH" >> ~/.bash_profile
```
или 

```
echo "export PATH=/Applications/ArmGNUToolchain/12.2.rel1/arm-none-eabi/bin/:\$PATH" >> ~/.zshrc
```
(В зависимости от используемой командной оболочки)
Разумеется, можно вписать эти строчки в соответствующие файлы и вручную, с помощью вашего любимого текстового редактора.

## Скачиваем дистрибутив RIOT и проверяем систему сборки

Исходные коды RIOT можно забрать с GitHub следующей командой (не забудьте вернуться в свой "домашний" каталог командой `cd ~`, или перейдите еще куда-нибудь):
```
cd ~
git clone https://github.com/a-podshivalov/RIOT.git
```
...а проверить, что сборка работает – вот так:
```
cd RIOT
git checkout miem_2023
cd examples-miem/hello-world
make
```
Могут понадобиться утилиты вроде make, unzip, wget и тому подобных, если их у вас нет - доустановите штатным для системы способом (`sudo apt install make unzip wget gdb-multiarch` в Ubuntu и WSL).

Программа компилируется для отладочной платы Nucleo L152RE. Если вы используете что-то другое, то исправьте соответствующим образом Makefile и настройки VSCode (если пользуетесь им).

## Отладчик

Для загрузки ваших программ в микроконтроллер понадобится отладчик OpenOCD:

http://openocd.org

В "нативной" Ubuntu (не в WSL!) он ставится штатным образом:
```
sudo apt-get install openocd
```
В WSL вам понадобится скачать один из его дистрибутивов для Windows, например, отсюда:

https://github.com/openocd-org/openocd/releases

Распакуйте архив с OpenOCD 0.12.0, например, в каталог openocd-0.12.0 на диске C. Далее исполняемый файл скопируем, убрав расширение, и добавим путь в `.bashrc`:
```
mkdir /mnt/c/openocd-v0.12.0
tar -C /mnt/c/openocd-v0.12.0/ -xzf /mnt/c/Users/YourName/Downloads/openocd-v0.12.0-i686-w64-mingw32.tar.gz
cd /mnt/c/openocd-v0.12.0/bin/
cp openocd.exe openocd
echo "export PATH=/mnt/c/openocd-v0.12.0/bin/:\$PATH" >> ~/.bashrc
```

Для работы OpenOCD в Windows с некоторыми отладчиками необходимо установить для них драйвер, поддерживающий libusb. Признак проблем с драйвером - ошибки библиотеки LibUSB при запуске OpenOCD, в особенности LIBUSB_DEVICE_NOT_FOUND. Они могут возникать по разным причинам, но если у вас отладчик отображается в "Диспетчере устройств" - то скорее всего, для него надо заменить драйвер. Это можно сделать с помощью программы Zadig, которая скачивается со своего официального сайта:

https://zadig.akeo.ie/

Укажите в окне программы ваш отладчик и установите для него драйвер WinUSB (v6.1.7600.16385).

На Mac OS X для установки OpenOCD можно использовать Homebrew.
```
brew install openocd
```
Для загрузки hello-world в микроконтроллер достаточно, находясь в каталоге с его Makefile выполнить следующую команду (иногда OpenOCD не сразу удается подключиться к микроконтроллеру, поэтому в таких случаях можно подержать кнопку RESET на плате отладочного адаптера):
```
make flash
```
...а для запуска отладчика GDB, который через OpenOCD может управлять выполнением программы в микроконтроллере, читать значения переменных и вообще, делать все, что полагается делать отладчику -
```
make debug
```
Если прошивка уже собрана - то можно воспользоваться командой
```
make flash-only
```
В этом случае прошивка пересобираться, что требует заметного времени, не будет.

Возможно, для корректной работы будет необходимо обновить версию GNU Make. Для этого нужно выполнить:
```
brew install make
export PATH="/usr/local/opt/make/libexec/gnubin:$PATH"
```
Проверяем версию:
```
make --version
```
Если версия GNU Make 4.0 и выше, добавляем путь в ~/.bash_profile или ~/.zshrc
```
echo "export PATH=/usr/local/opt/make/libexec/gnubin:\$PATH" >> ~/.bash_profile
```
или
```
echo "export PATH=/usr/local/opt/make/libexec/gnubin:\$PATH" >> ~/.zshrc
```

## Эмулятор терминала

Чтобы увидеть выводимые микроконтролером с помощью функций puts и printf в прошивке символы, а также для отправки данных в микроконтроллер по UART, понадобится эмулятор терминала. В Ubuntu обычно есть minicom или picocom, его можно запустить командой (проверьте, под каким названием у вас виден виртуальный COM-порт):
```
picocom /dev/ttyACM0 --baud 115200
```
В Windows можно использовать Hyper Terminal, ZOC Terminal, Putty (поддержка виртуальных COM-портов там довольно ограничена, но в целом достаточна), можно попробовать Termite:

https://www.compuphase.com/software_termite.htm

Отладочный адаптер UMDK-RF создает в системе два виртуальных COM-порта, в один из них отправляется информация об энергопотреблении подключенных к нему устройств, другой соединен с UART микроконтроллера.

## VSCode

Удобнее всего работать с кодом в какой-нибудь IDE, например, VSCode (да, можно настроить, к примеру, Eclipse, но VSCode хороша именно тем, что может работать просто как "умный" текстовый редактор, это удобно для небольших проектов). В VSCode нам понадобятся расширения WSL (его установите в первую очередь), C/C++ (вместе с ним ставится еще и C/C++ Themes для подсветки синтаксиса) и Native Debug (для работы с отладчиком gdb).

В `hello-world/.vscode` присутствуют настройки IDE, позволяющие выполнять сборку и отладку проекта. Их можно использовать для дальнейшей работы, создавая такие же по аналогии для своих нужд.

## Обещанный опрос

Как и было сказано на лекции, 1 балл за "практику" можно заработать, практически не напрягаясь - достаточно ответить на несколько вопросов и прислать ответы мне на email - либо apodshivalov@hse.ru, либо apodshivalov@miem.hse.ru. В процессе ответа на вопросы можно пользоваться чем угодно - любой справочной литературой, любыми ресурсами в интернете. Дедлайн для опроса - 20.01.2023, после этой даты ответы приниматься не будут.

1. Работали ли вы с чем-то из перечисленного (если да - то уточните)?
  * Linux, FreeBSD или другие Unix-подобные операционные системы (как пользователь)
  * ...как программист
  * Subversion, Git, Mercurial или другие системы контроля версий
  * микроконтроллеры (семейство/архитектура, например PIC, AVR, MSP430, STM32, MSP432, nRF51/52, ...)
  * Arduino
  * ST Nucleo, Discovery, TI Launchpad или другие подобные отладочные платы
  * Операционные системы для микроконтроллеров (FreeRTOS, ARM mbed, Zephyr OS, Riot, Contiki)
  * Raspberry Pi
2. Что означает ключевое слово volatile в языке Си?
  * ничего, компилятор может проигнорировать это ключевое слово
  * переменная, объявленная с модификатором volatile, может быть изменена не предусмотренным в программе способом
  * эту переменную можно безопасно использовать из разных потоков/процессов в многозадачной системе
  * запрещает некоторые оптимизации компилятора при обращении к этой переменной
3. Для чего в Си может быть использовано ключевое слово static? Перечислите возможные варианты.
4. Что означает в Си ключевое слово auto? А в Си++? Можно ли, используя это свойство, написать программу, которая компилировалась бы и как программа на Си, и как программа на Си++, но при этом выдавала бы разные результаты в зависимости от языка?
5. Какое максимальное значение может быть записано в переменную типа int? char? uint16_t?
6. Определите переменную a, типом которой является:
  * целое число (int)
  * указатель на целое число
  * массив из 10 целых чисел
  * массив из 10 указателей на целое число
  * указатель на массив из 10 целых чисел
  * указатель на функцию, принимающую в качестве аргумента целое число и возвращающую целое число
  * массив из 10 указателей на функции из предыдущего пункта
7. Что выведет этот фрагмент кода, и почему?
```c
    сhar *ptr;
    if ((ptr = (char*) malloc(0)) == NULL) {
        puts(“Got a null pointer”);
    } else {
        puts(“Got a valid pointer”);
    }
```
8.	Никуда не подглядывая, изобразите диодный мост.
9.	Микроконтроллер имеет напряжение питания 3,3 В, а работающее с ним периферийное устройство - 5 В (и соответствующие логические уровни). Каким способом лучше всего подключить их друг к другу и почему?
10.	Что происходит в этом видео? Правда ли, что на корпусе ноутбука может быть половина сетевого напряжения и если да - то как от этого избавиться? Если нет - то в чем нас обманывают авторы ролика?

https://zhovner.com/forever/110V_macbook.mp4

11.	Что такое открытый коллектор? ~~Почему канализационные люки делают круглыми?~~